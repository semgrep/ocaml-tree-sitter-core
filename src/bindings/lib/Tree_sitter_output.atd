(*
   Output generated by a tree-sitter parser.

   This is suitable for:
   - reading the json output from the tree-sitter CLI (and filtered so as to
     keep only json fields of interest)
   - converting a CST obtained from tree-sitter's C API directly (well, via
     OCaml bindings).
*)

type node_kind = [
  | Name of string
  | Literal of string
  | Error
] <ocaml repr="classic">

type node = {
  (* Original 'type' field, which by itself is ambiguous. Use 'kind'
     instead. *)
  type_ <json name="type">: string;

  start_pos <json name="startPosition">: position;
  end_pos <json name="endPosition">: position;

  ?children: node list option;
    (* Some children if 'type' field holds a grammar rule name,
       None if 'type' field holds a literal token. *)

  (*** Fields not part of the original tree-sitter data ***)

  (* Unique identifier for the kind of node. This is the 'type' field,
     tagged appropriately to avoid confusion. *)
  ~kind <ocaml default="Literal \"\"">: node_kind;

  (* Missing nodes are suggested by tree-sitter. They don't exist in the
     input. *)
  ~is_missing: bool;

 (* Unique ID assigned right after parsing the json file so as to facilitate
    further processing. *)
  ~id: int;
}

type position = {
  row: int; (* 0-based *)
  column: int; (* 0-based *)
}
